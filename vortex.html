<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Vortex Background (GSAP)</title>
  <style>
    :root{
      --bg: #000;
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.65);
      --card: rgba(255,255,255,.06);
      --stroke: rgba(255,255,255,.10);
    }

    *{ box-sizing:border-box; margin:0; padding:0; }
    body{
      min-height:100vh;
      background: var(--bg);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      overflow:hidden;
    }

    /* canvas sits behind everything */
    canvas#vortex{
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      display:block;
      pointer-events:none;
    }

    /* subtle vignette + film grain-ish overlay */
    .overlay{
      position: fixed;
      inset: 0;
      z-index: 1;
      pointer-events:none;
      background:
        radial-gradient(60% 60% at 50% 45%, rgba(0,0,0,0) 0%, rgba(0,0,0,.45) 70%, rgba(0,0,0,.80) 100%),
        radial-gradient(80% 80% at 50% 50%, rgba(255,255,255,.04) 0%, rgba(255,255,255,0) 55%);
      mix-blend-mode: normal;
    }
    .overlay::after{
      content:"";
      position:absolute;
      inset:-20%;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='180' height='180'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='180' height='180' filter='url(%23n)' opacity='.16'/%3E%3C/svg%3E");
      opacity:.10;
      transform: rotate(5deg);
      mix-blend-mode: overlay;
    }

    /* foreground content */
    .wrap{
      position: relative;
      z-index: 2;
      height: 100vh;
      display:grid;
      place-items:center;
      padding: 28px;
    }

    .hero{
      width: min(980px, 100%);
      border: 1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
      backdrop-filter: blur(10px);
      border-radius: 22px;
      padding: clamp(18px, 3vw, 34px);
      box-shadow: 0 30px 120px rgba(0,0,0,.55);
      overflow:hidden;
      position:relative;
    }

    .hero::before{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(700px 350px at 20% 10%, rgba(255,255,255,.10) 0%, rgba(255,255,255,0) 60%);
      pointer-events:none;
    }

    h1{
      font-size: clamp(28px, 4vw, 54px);
      line-height: 1.05;
      letter-spacing: -0.02em;
      margin-bottom: 10px;
    }
    p{
      color: var(--muted);
      font-size: clamp(14px, 1.4vw, 18px);
      line-height: 1.45;
      max-width: 60ch;
    }

    .row{
      display:flex;
      gap: 12px;
      margin-top: 18px;
      flex-wrap:wrap;
      align-items:center;
    }

    .btn{
      appearance:none;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding: 12px 14px;
      border-radius: 14px;
      cursor:pointer;
      font-weight:600;
      letter-spacing:.01em;
      transition: transform .2s ease, background .2s ease, border-color .2s ease;
    }
    .btn:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,.09);
      border-color: rgba(255,255,255,.22);
    }
    .pill{
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      color: rgba(255,255,255,.78);
    }

    /* mobile scroll fallback */
    @media (max-width: 640px){
      body{ overflow:hidden; }
      .hero{ border-radius: 18px; }
    }
  </style>
</head>

<body>
  <canvas id="vortex"></canvas>
  <div class="overlay"></div>

  <main class="wrap">
    <section class="hero">
      <div class="pill">GSAP + Canvas Vortex Background</div>
      <h1>Black site with a vortex motion backdrop.</h1>
      <p>
        Smooth swirl particles, subtle parallax, and a soft glowâ€”built as a background layer so you can drop your real sections on top.
      </p>
      <div class="row">
        <button class="btn" id="boost">Boost Swirl</button>
        <button class="btn" id="calm">Calm Down</button>
      </div>
    </section>
  </main>

  <!-- GSAP -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

  <script>
    // ---------------------------
    // VORTEX BACKGROUND (CANVAS)
    // ---------------------------
    const canvas = document.getElementById("vortex");
    const ctx = canvas.getContext("2d", { alpha: true });

    const state = {
      w: 0, h: 0, dpr: Math.max(1, Math.min(2, window.devicePixelRatio || 1)),
      cx: 0, cy: 0,
      t: 0,
      // tuning knobs
      swirl: 1.0,
      speed: 0.0105,
      pull: 0.78,
      spread: 0.92,
      glow: 0.55,
      // mouse parallax
      mx: 0, my: 0,
      px: 0, py: 0
    };

    function resize(){
      state.w = Math.floor(window.innerWidth);
      state.h = Math.floor(window.innerHeight);
      canvas.width  = Math.floor(state.w * state.dpr);
      canvas.height = Math.floor(state.h * state.dpr);
      canvas.style.width  = state.w + "px";
      canvas.style.height = state.h + "px";
      ctx.setTransform(state.dpr, 0, 0, state.dpr, 0, 0);
      state.cx = state.w * 0.5;
      state.cy = state.h * 0.5;
    }
    window.addEventListener("resize", resize, { passive: true });
    resize();

    // Particles (stored in polar-ish coordinates)
    const COUNT = Math.min(1400, Math.floor((state.w * state.h) / 900)); // auto scale
    const particles = [];
    const rand = (a,b)=> a + Math.random() * (b-a);

    function makeParticles(){
      particles.length = 0;
      const maxR = Math.hypot(state.w, state.h) * 0.55;
      for(let i=0;i<COUNT;i++){
        const r = Math.pow(Math.random(), state.spread) * maxR + 10;
        const a = rand(0, Math.PI * 2);
        const z = Math.random();                 // depth factor 0..1
        const s = rand(0.3, 1.2) * (0.35 + z);    // size
        const tw = rand(0.2, 1.0) * (0.6 + z);    // twinkle
        particles.push({ r, a, z, s, tw });
      }
    }
    makeParticles();

    // Mouse parallax
    window.addEventListener("pointermove", (e) => {
      const x = (e.clientX / state.w) * 2 - 1;
      const y = (e.clientY / state.h) * 2 - 1;
      state.mx = x;
      state.my = y;
    }, { passive:true });

    function clear(){
      // fade trails
      ctx.fillStyle = "rgba(0,0,0,0.22)";
      ctx.fillRect(0,0,state.w,state.h);
    }

    function draw(){
      state.t += state.speed;

      // smooth mouse
      state.px += (state.mx - state.px) * 0.06;
      state.py += (state.my - state.py) * 0.06;

      clear();

      const maxR = Math.hypot(state.w, state.h) * 0.55;
      const cx = state.cx + state.px * 40;
      const cy = state.cy + state.py * 30;

      // center glow (subtle)
      const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, maxR * 0.9);
      g.addColorStop(0.0, `rgba(255,255,255,${0.06 * state.glow})`);
      g.addColorStop(0.35, `rgba(255,255,255,${0.02 * state.glow})`);
      g.addColorStop(1.0, "rgba(255,255,255,0)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,state.w,state.h);

      // draw particles
      ctx.globalCompositeOperation = "lighter";

      for(const p of particles){
        // inward pull for vortex
        p.r *= (1 - (0.0009 * state.pull) * (0.3 + p.z));
        if(p.r < 16){
          // respawn outward
          p.r = maxR * (0.75 + Math.random()*0.25);
          p.a = rand(0, Math.PI*2);
          p.z = Math.random();
        }

        // swirl: angular velocity increases towards center
        const centerBoost = (1 - Math.min(1, p.r / maxR));
        const av = (0.004 + 0.020 * centerBoost) * state.swirl * (0.35 + p.z);
        p.a += av;

        // convert polar -> cartesian with a slight spiral wobble
        const wob = Math.sin(state.t * (1.5 + p.z) + p.a * 2.0) * (2 + 8 * centerBoost);
        const x = cx + Math.cos(p.a) * p.r + wob * 0.25;
        const y = cy + Math.sin(p.a) * p.r + wob * 0.18;

        // brightness/twinkle by depth + radius
        const rNorm = p.r / maxR;
        const alpha = (0.08 + 0.55 * (1 - rNorm)) * (0.35 + p.z) * (0.65 + 0.35*Math.sin(state.t*3.2 + p.tw*10));
        const size  = (p.s * (0.7 + 2.4*(1 - rNorm))) * 0.9;

        // color shifts: white to slightly cool
        const cool = 210 + Math.floor(30 * (1 - rNorm));
        ctx.fillStyle = `rgba(255,255,255,${alpha})`;
        // tiny soft glow
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI*2);
        ctx.fill();

        // occasional colored spark
        if(p.z > 0.82 && centerBoost > 0.2){
          ctx.fillStyle = `rgba(${cool},255,230,${alpha*0.25})`;
          ctx.beginPath();
          ctx.arc(x, y, size*1.8, 0, Math.PI*2);
          ctx.fill();
        }
      }

      ctx.globalCompositeOperation = "source-over";
    }

    // GSAP ticker for consistent motion + easy tuning
    gsap.ticker.fps(60);
    gsap.ticker.add(draw);

    // UI controls
    const boostBtn = document.getElementById("boost");
    const calmBtn  = document.getElementById("calm");

    boostBtn.addEventListener("click", () => {
      gsap.to(state, { swirl: 1.55, speed: 0.014, pull: 0.92, glow: 0.8, duration: 0.7, ease: "power2.out" });
    });
    calmBtn.addEventListener("click", () => {
      gsap.to(state, { swirl: 0.95, speed: 0.0105, pull: 0.78, glow: 0.55, duration: 0.7, ease: "power2.out" });
    });

    // Reduce motion preference
    if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) {
      gsap.ticker.remove(draw);
      // draw one frame
      ctx.fillStyle = "#000";
      ctx.fillRect(0,0,state.w,state.h);
      // subtle static glow
      const maxR = Math.hypot(state.w, state.h) * 0.55;
      const cx = state.cx, cy = state.cy;
      const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, maxR);
      g.addColorStop(0.0, "rgba(255,255,255,0.06)");
      g.addColorStop(1.0, "rgba(255,255,255,0)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,state.w,state.h);
    }
  </script>
</body>
</html>