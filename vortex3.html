<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Across-Screen Vapor Bands (Smooth / No Pixels)</title>
  <style>
    :root{
      --bg:#000;
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.65);
      --stroke:rgba(255,255,255,.10);
    }
    *{box-sizing:border-box;margin:0;padding:0}
    body{
      min-height:100vh;
      background:var(--bg);
      color:var(--text);
      font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      overflow:hidden;
    }

    canvas#vapor{
      position:fixed; inset:0;
      width:100%; height:100%;
      z-index:0;
      display:block;
      pointer-events:none;
    }

    /* ✅ very light vignette (not a dark “screen overlay”) */
    .overlay{
      position:fixed;
      inset:0;
      z-index:1;
      pointer-events:none;
      background:
        radial-gradient(
          90% 90% at 50% 45%,
          rgba(0,0,0,0) 0%,
          rgba(0,0,0,.09) 72%,
          rgba(0,0,0,.22) 100%
        );
    }

    .wrap{
      position:relative;
      z-index:2;
      height:100vh;
      display:grid;
      place-items:center;
      padding:28px;
    }
    .hero{
      width:min(980px,100%);
      border:1px solid var(--stroke);
      background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
      backdrop-filter:blur(10px);
      border-radius:22px;
      padding:clamp(18px,3vw,34px);
      box-shadow:0 30px 120px rgba(0,0,0,.55);
    }
    .pill{
      font-size:12px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.04);
      color:rgba(255,255,255,.78);
      display:inline-block;
      margin-bottom:10px;
    }
    h1{
      font-size:clamp(28px,4vw,54px);
      line-height:1.05;
      letter-spacing:-0.02em;
      margin-bottom:10px;
    }
    p{
      color:var(--muted);
      font-size:clamp(14px,1.4vw,18px);
      line-height:1.45;
      max-width:60ch;
    }
  </style>
</head>

<body>
  <canvas id="vapor"></canvas>
  <div class="overlay"></div>

  <main class="wrap">
    <section class="hero">
      <span class="pill">Smooth vapor bands</span>
      <h1>Across-screen flows, airy & pixel-free.</h1>
      <p>Fixes pixel blocks by removing DPR double-scaling and adding a soft blur composite (more vapor).</p>
    </section>
  </main>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
  <script>
    const canvas = document.getElementById("vapor");
    const ctx = canvas.getContext("2d", { alpha:true });

    // Offscreen buffer (we render the sim here, then blur-composite to main)
    const buf = document.createElement("canvas");
    const btx = buf.getContext("2d", { alpha:true });

    const S = {
      w:0, h:0,
      dpr: Math.max(1, Math.min(2, window.devicePixelRatio || 1)),
      t:0,

      // slow drift
      speed: 0.0046,

      // ✅ smoothness / pixel control
      // Higher scale = less pixelation. We also blur composite, so this stays airy.
      scale: 0.70,     // (0.65–0.85 recommended)
      fade: 0.22,     // less fade = more presence
        glow: 0.25,      // tiny bump (still subtle)
    density: 0.66,   // stronger vapor overall

      // across-screen band behavior
      amp: 0.16,
      drift: 0.16,
      band: 0.16,
      breakUp: 1.05,

      // composite blur (kills pixel blocks)
      blurBase: 10,    // main blur pass
      blurDetail: 4,   // definition pass
      blurGlow: 14,    // bloom pass

      // mouse drift
      mx:0, my:0, px:0, py:0
    };

    function resize(){
      S.w = Math.floor(window.innerWidth);
      S.h = Math.floor(window.innerHeight);

      // Main canvas uses DPR for sharp UI layers
      canvas.width  = Math.floor(S.w * S.dpr);
      canvas.height = Math.floor(S.h * S.dpr);
      canvas.style.width  = S.w + "px";
      canvas.style.height = S.h + "px";
      ctx.setTransform(S.dpr,0,0,S.dpr,0,0);

      // ✅ Buffer does NOT use DPR (prevents sampling artifacts / “grid” pixels)
      // Render buffer in its own pixel space
      buf.width  = Math.floor(S.w * S.scale);
      buf.height = Math.floor(S.h * S.scale);
      btx.setTransform(1,0,0,1,0,0);

      // store for step()
      S.bw = buf.width;
      S.bh = buf.height;

      // Quality hints
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      btx.imageSmoothingEnabled = true;
      btx.imageSmoothingQuality = "high";

      // clear
      btx.fillStyle = "rgba(0,0,0,1)";
      btx.fillRect(0,0,S.bw,S.bh);
      ctx.clearRect(0,0,S.w,S.h);
    }
    window.addEventListener("resize", resize, { passive:true });
    resize();

    window.addEventListener("pointermove", (e)=>{
      S.mx = (e.clientX / S.w) * 2 - 1;
      S.my = (e.clientY / S.h) * 2 - 1;
    }, { passive:true });

    const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));

    // organic-ish fast noise
    function n2(x,y){
      return Math.sin(x*1.7 + Math.cos(y*1.3)) * Math.cos(y*1.5 + Math.sin(x*1.1));
    }

    // Airy puff (no bright white hotspot)
    function puff(x,y,r, colA, colB, a){
      const g = btx.createRadialGradient(x,y,0, x,y,r);
      g.addColorStop(0.00, colA.replace("{a}", (0.52*a).toFixed(4)));
      g.addColorStop(0.38, colB.replace("{a}", (0.46*a).toFixed(4)));
      g.addColorStop(0.78, colA.replace("{a}", (0.15*a).toFixed(4)));
      g.addColorStop(1.00, colA.replace("{a}", "0"));
      btx.fillStyle = g;
      btx.beginPath();
      btx.arc(x,y,r,0,Math.PI*2);
      btx.fill();
    }

    // Across-screen centerline
    function ribbonY(u, yBase, amp, phase){
      const t = S.t;
      const f1 = Math.sin(t*0.95 + u*6.2 + phase);
      const f2 = Math.sin(t*0.55 + u*13.0 - phase*0.7);
      const f3 = Math.sin(t*1.35 + u*3.2);
      const wave = f1*0.55 + f2*0.30 + f3*0.15;
      return yBase + wave * amp;
    }

    function step(){
      S.t += S.speed;

      // mouse drift
      S.px += (S.mx - S.px) * 0.03;
      S.py += (S.my - S.py) * 0.03;

      const W = S.bw;
      const H = S.bh;

      // fade buffer (trails)
      btx.globalCompositeOperation = "source-over";
      btx.fillStyle = `rgba(0,0,0,${S.fade})`;
      btx.fillRect(0,0,W,H);

      // draw vapor
      btx.globalCompositeOperation = "lighter";

      const layers = [
        { y: 0.33, amp: S.amp*0.85, phase: 0.0,  drift:  0.14, tint: 0.0,  strength: 0.92 },
        { y: 0.56, amp: S.amp*1.05, phase: 1.4,  drift: -0.10, tint: 1.3,  strength: 0.80 },
        { y: 0.74, amp: S.amp*0.95, phase: 2.25, drift:  0.08, tint: 2.2,  strength: 0.70 }
      ];

      for(const L of layers){
        const sweep  = (Math.sin(S.t*0.55 + L.phase) * 0.5 + 0.5);
        const xShift = (sweep * 0.7 + 0.15) * W * L.drift;

        const steps = 120; // continuous bands across screen

        for(let i=0;i<=steps;i++){
          const u = i/steps;

          const x  = u*(W+240) - 120 + xShift + S.px*16;
          const yC = ribbonY(u, H*L.y, H*L.amp, L.phase) + S.py*12;

          const band = (S.band * H);

          const tt = S.t*0.9 + L.phase + u*2.0;
          const wx = n2(tt*0.8, u*4.0 + L.phase);
          const wy = n2(u*3.0 - L.phase, tt*0.7);

          const jx = wx * band * 0.36 * S.breakUp;
          const jy = wy * band * 0.30 * S.breakUp;

          // soft color drift; includes #54f3a4 (mint) but avoids too much white
          const c1 = (Math.sin(S.t*0.30 + L.tint + u*2.1)*0.5 + 0.5);
          const c2 = (Math.cos(S.t*0.24 - L.tint + u*1.7)*0.5 + 0.5);

          const A = `rgba(${Math.floor(84 + 22*c2)}, ${Math.floor(243 - 18*c1)}, ${Math.floor(164 + 34*c1)}, {a})`; // mint
          const B = `rgba(${Math.floor(72 + 16*c1)}, ${Math.floor(155 + 120*c2)}, ${Math.floor(125 + 26*c2)}, {a})`;

          const end = 1 - Math.pow(Math.abs(u-0.5)*2, 1.05);

          // PASS 1: wide haze sheet (defines long band, still vapor)
          const r1 = clamp(band * (1.18 + 0.35*Math.sin(tt)), 52, 220);
          const a1 = (0.010 + 0.010*c1) * S.density * L.strength * (0.40 + 0.60*end);
          puff(x, yC, r1, A, B, a1);

          // PASS 2: wisps / inner turbulence
          const r2 = clamp(r1*0.40, 20, 88);
          const a2 = a1 * 0.78;
          puff(x + jx, yC + jy, r2, B, A, a2);

          const off = (wy * 0.5 + 0.5) * band * 0.90;
          puff(x - jx*0.55, yC + off*0.32, r2*0.78, A, B, a2*0.50);
          puff(x + jx*0.45, yC - off*0.30, r2*0.72, B, A, a2*0.46);
        }

        // super soft background volume (very low alpha)
        const hx = W*0.5 + Math.sin(S.t*0.28 + L.phase)*W*0.12 + S.px*10;
        const hy = H*L.y + Math.cos(S.t*0.26 - L.phase)*H*0.10 + S.py*8;
        puff(hx, hy, Math.hypot(W,H)*0.22, "rgba(84,243,164,{a})", "rgba(170,110,255,{a})", 0.009*S.density);
      }

      btx.globalCompositeOperation = "source-over";

      // ✅ Pixel-killing composite: blur the buffer as we upscale
      ctx.globalCompositeOperation = "source-over";
      ctx.clearRect(0,0,S.w,S.h);

      // base pass (soft)
      ctx.save();
      ctx.filter = `blur(${S.blurBase}px)`;
      ctx.globalAlpha = 1;
      ctx.drawImage(buf, 0, 0, W, H, 0, 0, S.w, S.h);
      ctx.restore();

      // detail pass (less blur, still smooth)
      ctx.save();
      ctx.filter = `blur(${S.blurDetail}px)`;
      ctx.globalCompositeOperation = "lighter";
      ctx.globalAlpha = 0.55;
      ctx.drawImage(buf, 0, 0, W, H, 0, 0, S.w, S.h);
      ctx.restore();

      // glow pass (very soft)
      ctx.save();
      ctx.filter = `blur(${S.blurGlow}px)`;
      ctx.globalCompositeOperation = "lighter";
      ctx.globalAlpha = S.glow;
      ctx.drawImage(buf, 0, 0, W, H, 0, 0, S.w, S.h);
      ctx.restore();

      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = "source-over";
      ctx.filter = "none";
    }

    gsap.ticker.fps(60);
    gsap.ticker.add(step);

    // Reduced motion
    if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) {
      gsap.ticker.remove(step);
      for(let i=0;i<20;i++) step();
    }
  </script>
</body>
</html>