<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Design / Development / Growth – GSAP Modes</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@500;700;800&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg: #000;
      --ink: #fff;
      --muted: rgba(255,255,255,.62);
      --stroke: rgba(255,255,255,.10);
    }

    *{ box-sizing:border-box; }
    html, body{ height:100%; }
    body{
      margin:0;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: var(--bg);
      color: var(--ink);
      overflow-x: hidden;
    }

    .hero{
      min-height: 100vh;
      width: 100%;
      display: grid;
      place-items: center;
      padding: clamp(18px, 4vw, 48px);
    }

    .image-box{
      width: min(72vw, 520px);
      aspect-ratio: 2 / 3;
      background: rgba(255,255,255,0.03);
      border: 1px solid var(--stroke);
      border-radius: 22px;
      position: relative;
      overflow: hidden;
      box-shadow:
        0 30px 80px rgba(0,0,0,.55),
        inset 0 1px 0 rgba(255,255,255,.06);
    }

    .image-box::before,
    .mini-box::before{
      content:"";
      position:absolute;
      inset:0;
      pointer-events:none;
      background:
        radial-gradient(900px 700px at 30% 20%, rgba(255,255,255,.06), transparent 55%),
        radial-gradient(800px 550px at 80% 70%, rgba(255,255,255,.05), transparent 60%),
        linear-gradient(to bottom, rgba(255,255,255,.03), transparent 40%, rgba(255,255,255,.02));
      mix-blend-mode: screen;
      opacity: .65;
    }

    .word{
      position:absolute;
      inset:0;
      display:grid;
      place-items:center;
      z-index: 5;
      text-transform: uppercase;
      letter-spacing: .18em;
      font-weight: 800;
      font-size: clamp(28px, 4.2vw, 48px);
    }

    .word-line{
      display: inline-flex;
      align-items: baseline;
      justify-content: center;
      gap: 0.02em;
      letter-spacing: inherit;
      white-space: nowrap;
      padding: 0 16px;
      text-align:center;
    }

    .word span{
      display:inline-block;
      transform: translateY(18px);
      opacity:0;
      filter: blur(6px);
    }

    .shapes{
      position:absolute;
      inset:0;
      z-index: 2;
    }

    .shape{
      position:absolute;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.22);
      background: rgba(255,255,255,.06);
      box-shadow: 0 25px 60px rgba(0,0,0,.55);
      opacity: 0;
      transform: translate3d(0,0,0);
      will-change: transform, border-radius, filter, opacity;
    }
    .shape--ring{
      background: transparent;
      box-shadow: none;
      border-width: 1px;
    }
    .shape--soft{
      border-color: rgba(255,255,255,.12);
      background: rgba(255,255,255,.08);
    }
    .shape--bar{
      border-radius: 18px;
    }

    /* themes */
    .theme-design{
      --c1: rgba(16,255,163,.24);
      --c2: rgba(16,255,163,.08);
      --c3: rgba(255,255,255,.18);
    }
    .theme-development{
      --c1: rgba(120,140,255,.24);
      --c2: rgba(120,140,255,.08);
      --c3: rgba(255,255,255,.18);
    }
    .theme-growth{
      --c1: rgba(255,190,70,.24);
      --c2: rgba(255,190,70,.08);
      --c3: rgba(255,255,255,.18);
    }

    .themed .shape{
      border-color: var(--c1);
      background: var(--c2);
    }
    .themed .shape--ring{
      background: transparent;
      border-color: var(--c1);
    }
    .themed .shape--bar{
      border-color: var(--c3);
      background: rgba(255,255,255,.05);
    }

    .caption{
      position:absolute;
      left: 18px;
      right: 18px;
      bottom: 16px;
      z-index: 6;
      display:flex;
      justify-content: space-between;
      align-items:center;
      font-size: 12px;
      letter-spacing: .06em;
      text-transform: uppercase;
      color: var(--muted);
    }
    .caption .dot{
      width: 7px;
      height: 7px;
      border-radius: 99px;
      background: rgba(255,255,255,.55);
      box-shadow: 0 0 0 5px rgba(255,255,255,.08);
    }

    .sections{
      width: min(1100px, 100%);
      margin: 0 auto;
      padding: 0 clamp(18px, 4vw, 48px) 90px;
      display: grid;
      gap: 28px;
    }
    .panel{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap: 24px;
      align-items:center;
      padding: 26px;
      border-radius: 22px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
    }
    @media (max-width: 900px){
      .panel{ grid-template-columns: 1fr; }
    }

    .panel h2{
      margin:0 0 10px;
      font-size: clamp(22px, 2.4vw, 30px);
      letter-spacing: -.02em;
    }
    .panel p{
      margin:0;
      color: rgba(255,255,255,.70);
      line-height: 1.6;
      max-width: 60ch;
    }

    .mini-box{
      width: 100%;
      aspect-ratio: 2/3;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.02);
      position: relative;
      overflow:hidden;
      box-shadow: 0 18px 50px rgba(0,0,0,.45);
    }

    .mini-word{
      position:absolute;
      inset:0;
      display:grid;
      place-items:center;
      font-weight: 800;
      letter-spacing: .16em;
      text-transform: uppercase;
      opacity: .95;
      z-index: 5;
      padding: 12px;
    }
    .mini-word span{
      display:inline-block;
      opacity:0;
      transform: translateY(14px);
      filter: blur(6px);
    }

    .mini-cap{
      position:absolute;
      left: 14px;
      right: 14px;
      bottom: 12px;
      display:flex;
      justify-content: space-between;
      align-items:center;
      font-size: 11px;
      letter-spacing: .08em;
      text-transform: uppercase;
      color: rgba(255,255,255,.55);
      z-index: 6;
    }

/* DEVELOPMENT square-path mode */
.mode-squarepath{
  --track: rgba(120,140,255,.38);
  --trackGlow: rgba(120,140,255,.14);
  --runner: rgba(120,140,255,.95);
  --runnerGlow: rgba(120,140,255,.45);
}

/* SVG occupies same inner area as previous shapes */
.mode-squarepath .track-svg{
  position:absolute;
  inset: -10%;              /* ✅ matches visual padding of other boxes */
  z-index: 3;
  pointer-events:none;
}

/* square line */
.mode-squarepath .track-path{
  fill: none;
  stroke: var(--track);
  stroke-width: 1.4;
  vector-effect: non-scaling-stroke;
  filter: drop-shadow(0 0 10px var(--trackGlow));
}

/* moving dot */
.mode-squarepath .runner{
  position:absolute;
  width: 12px;
  height: 12px;
  border-radius: 999px;
  background: var(--runner);
  z-index: 4;
  box-shadow:
    0 0 0 6px rgba(120,140,255,.12),
    0 0 18px var(--runnerGlow);
  pointer-events:none;
}
/* system dot (design mode only) */
.mode-morph .sys-dot{
  position: absolute;
  width: 10px;
  height: 10px;
  border-radius: 999px;
  background: rgba(16,255,163,.95);
  box-shadow:
    0 0 0 6px rgba(16,255,163,.12),
    0 0 18px rgba(16,255,163,.45);
  z-index: 4;
  pointer-events: none;
  will-change: transform;
}
/* ✅ DOT GRID (DESIGN BOX ONLY) */
#designBox .dot-grid{
  position:absolute;
  inset: 0;
  z-index: 2;                 /* behind text */
  pointer-events:none;

  /* inner padding so dots don't hit the border */
  padding: 26px;

  display:grid;
  place-items:center;

  /* soft vignette (premium fade) */
  -webkit-mask-image: radial-gradient(circle at 50% 45%, #000 58%, transparent 82%);
  mask-image: radial-gradient(circle at 50% 45%, #000 58%, transparent 82%);
}

#designBox .dot{
  width: var(--dotSize, 6px);
  height: var(--dotSize, 6px);
  border-radius: 999px;

  background: rgba(16,255,163,.22);
  box-shadow: 0 0 0 5px rgba(16,255,163,.06);

  transform: scale(var(--s, 1));
  opacity: var(--o, .75);
  will-change: transform, opacity;
}
  </style>
  
</head>

<body>

  <!-- HERO: DESIGN (morphing) -->
  <section class="hero">
    <div class="image-box themed theme-design mode-morph" id="designBox" data-mode="morph">
     
      <div class="dot-grid" aria-hidden="true"></div>
      <div class="sys-dot" aria-hidden="true"></div>
      <div class="word" aria-label="DESIGN">
        <div class="word-line">
          <span>D</span><span>E</span><span>S</span><span>I</span><span>G</span><span>N</span>
        </div>
      </div>

      <div class="caption">
        <div style="display:flex;gap:10px;align-items:center;">
          <span class="dot"></span>
          <span>Studio Motion Study</span>
        </div>
        <span>01</span>
      </div>
    </div>
  </section>

  <!-- TEXT SECTIONS -->
  <section class="sections">

    <!-- DESIGN mini: morphing shapes -->
    <div class="panel">
      <div>
        <h2>Design</h2>
        <p>Clarity, hierarchy, and intentional detail — visuals that feel calm but high-end.</p>
      </div>

      <div class="mini-box themed theme-design mode-morph" data-mode="morph">
        <div class="shapes">
          <div class="shape shape--ring" style="width:170px;height:170px;left:-60px;top:40px;"></div>
          <div class="shape shape--soft" style="width:110px;height:110px;right:24px;top:60px;"></div>
          <div class="shape shape--bar"  style="width:210px;height:52px;left:40px;bottom:80px;"></div>
          <div class="shape shape--soft" style="width:140px;height:140px;right:-50px;bottom:120px;"></div>
        </div>
        <div class="dot-grid" aria-hidden="true"></div>
        <div class="sys-dot" aria-hidden="true"></div>
        <div class="mini-word" aria-label="DESIGN">
          <div class="word-line">
            <span>D</span><span>E</span><span>S</span><span>I</span><span>G</span><span>N</span>
          </div>
        </div>

        <div class="mini-cap"><span>Visual System</span><span>02</span></div>
      </div>
    </div>

    <!-- DEVELOPMENT mini: shapes moving on a line -->
    <div class="panel">
      <div>
        <h2>Development</h2>
        <p>Fast, clean builds with motion that stays smooth on real devices.</p>
      </div>

      <div class="mini-box themed theme-development mode-squarepath">

        <!-- square path (same inner padding as shapes used before) -->
        <svg class="track-svg" viewBox="0 0 100 150" aria-hidden="true">
            <path class="track-path"
            d="
                M28,38
                H72
                Q78,38 78,44
                V106
                Q78,112 72,112
                H28
                Q22,112 22,106
                V44
                Q22,38 28,38
                Z
            "
            />
        </svg>

        <!-- moving circle -->
        <div class="runner"></div>

        <!-- word -->
        <div class="mini-word" aria-label="DEVELOPMENT">
            <div class="word-line">
            <span>D</span><span>E</span><span>V</span><span>E</span><span>L</span>
            <span>O</span><span>P</span><span>M</span><span>E</span><span>N</span><span>T</span>
            </div>
        </div>

        <div class="mini-cap">
            <span>Build & Motion</span>
            <span>03</span>
        </div>
        </div>
    </div>

    <!-- GROWTH mini: shapes growing -->
    <div class="panel">
      <div>
        <h2>Growth</h2>
        <p>Systems that convert: SEO structure, performance, and the right CTAs.</p>
      </div>

      <div class="mini-box themed theme-growth mode-grow" data-mode="grow">
        <div class="shapes">
          <div class="shape shape--ring" style="width:210px;height:210px;left:-70px;top:60px;"></div>
          <div class="shape shape--soft" style="width:120px;height:120px;right:28px;top:66px;"></div>
          <div class="shape shape--soft" style="width:160px;height:160px;right:-70px;bottom:120px;"></div>
          <div class="shape shape--bar"  style="width:220px;height:52px;left:42px;bottom:86px;"></div>
          <div class="shape shape--ring" style="width:130px;height:130px;left:90px;top:210px;"></div>
        </div>

        <div class="mini-word" aria-label="GROWTH">
          <div class="word-line">
            <span>G</span><span>R</span><span>O</span><span>W</span><span>T</span><span>H</span>
          </div>
        </div>

        <div class="mini-cap"><span>Scale Signals</span><span>04</span></div>
      </div>
    </div>

  </section>

  <!-- GSAP -->
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/gsap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/ScrollTrigger.min.js"></script>

  <script>
gsap.registerPlugin(ScrollTrigger);

/* -----------------------------------------
   LETTER ANIMATION
----------------------------------------- */
function animateLetters(container, opts = {}) {
  const spans = container.querySelectorAll("span");
  return gsap.to(spans, {
    opacity: 1,
    y: 0,
    filter: "blur(0px)",
    duration: opts.duration ?? 0.75,
    ease: "power3.out",
    stagger: opts.stagger ?? 0.05
  });
}

/* -----------------------------------------
   INTRO (fade + lift)
----------------------------------------- */
function introBox(box, opts = {}) {
  const shapes = box.querySelectorAll(".shape");
  const word   = box.querySelector(".word, .mini-word");

  gsap.set(shapes, { opacity: 0, scale: 0.82, y: 22, rotate: -8 });
  if (word) {
    gsap.set(word.querySelectorAll("span"), {
      opacity: 0,
      y: 16,
      filter: "blur(6px)"
    });
  }

  const tl = gsap.timeline({ defaults: { ease: "power3.out" } });
  tl.to(shapes, { opacity: 1, duration: 0.6, stagger: 0.08 }, 0);
  tl.to(shapes, { scale: 1, y: 0, rotate: 0, duration: 1.0, stagger: 0.08 }, 0);
  if (word) tl.add(animateLetters(word, opts), 0.18);

  return tl;
}

/* -----------------------------------------
   MODE: DESIGN — Orbit + Breathe
----------------------------------------- */
function runMorph(shapes, strength = 1) {
  shapes.forEach((el, i) => {
    gsap.killTweensOf(el);

    const drift = (8 + i * 2) * strength;

    gsap.to(el, {
      x: (i % 2 ? drift : -drift),
      y: (i % 3 ? -drift : drift),
      duration: 3.2 + i * 0.3,
      ease: "sine.inOut",
      yoyo: true,
      repeat: -1
    });

    gsap.to(el, {
      rotate: i % 2 ? 10 : -10,
      duration: 4.5 + i * 0.35,
      ease: "sine.inOut",
      yoyo: true,
      repeat: -1
    });

    gsap.to(el, {
      scale: 1.05 - i * 0.01,
      duration: 2.4 + i * 0.2,
      ease: "sine.inOut",
      yoyo: true,
      repeat: -1
    });

    gsap.to(el, {
      opacity: 0.75,
      duration: 2.8 + i * 0.2,
      ease: "sine.inOut",
      yoyo: true,
      repeat: -1
    });
  });
}

/* -----------------------------------------
   DESIGN — SYSTEM DOT (BOUNCING)
----------------------------------------- */
function runSystemDot(box) {
  const dot = box.querySelector(".sys-dot");
  if (!dot || dot._tick) return;

  // dot size (so we can hit edges correctly)
  const size = () => ({
    w: dot.offsetWidth || 10,
    h: dot.offsetHeight || 10
  });

  let vx = gsap.utils.random(0.6, 1.1) * (Math.random() > 0.5 ? 1 : -1);
  let vy = gsap.utils.random(0.6, 1.1) * (Math.random() > 0.5 ? 1 : -1);

  // start anywhere inside the box (top-left based coords)
  const rect0 = box.getBoundingClientRect();
  const s0 = size();
  let x = gsap.utils.random(0, Math.max(0, rect0.width  - s0.w));
  let y = gsap.utils.random(0, Math.max(0, rect0.height - s0.h));

  gsap.set(dot, { x, y, opacity: 0 });
  gsap.to(dot, { opacity: 1, duration: 0.6, ease: "power2.out" });

  function tick() {
    const rect = box.getBoundingClientRect();
    const s = size();

    x += vx;
    y += vy;

    // LEFT / RIGHT (hit the edge exactly)
    if (x <= 0) {
      x = 0;
      vx *= -1;
      gsap.to(dot, { scale: 1.35, duration: 0.12, yoyo: true, repeat: 1, ease: "power2.out" });
    } else if (x >= rect.width - s.w) {
      x = rect.width - s.w;
      vx *= -1;
      gsap.to(dot, { scale: 1.35, duration: 0.12, yoyo: true, repeat: 1, ease: "power2.out" });
    }

    // TOP / BOTTOM
    if (y <= 0) {
      y = 0;
      vy *= -1;
      gsap.to(dot, { scale: 1.35, duration: 0.12, yoyo: true, repeat: 1, ease: "power2.out" });
    } else if (y >= rect.height - s.h) {
      y = rect.height - s.h;
      vy *= -1;
      gsap.to(dot, { scale: 1.35, duration: 0.12, yoyo: true, repeat: 1, ease: "power2.out" });
    }

    gsap.set(dot, { x, y });
  }

  gsap.ticker.add(tick);
  dot._tick = tick;
}

/* -----------------------------------------
   MODE RUNNER
----------------------------------------- */
function runMode(box, opts = {}) {
  const mode = box.dataset.mode || "morph";
  const shapes = box.querySelectorAll(".shape");

  const tl = introBox(box, {
    duration: 0.7,
    stagger: opts.letterStagger ?? 0.05
  });

  tl.call(() => {
    if (mode === "morph") {
      runMorph(shapes, opts.morphStrength ?? 1);
      runSystemDot(box);
    }
  }, null, ">");

  return tl;
}

/* -----------------------------------------
   HERO
----------------------------------------- */
runMode(document.querySelector("#designBox"), {
  letterStagger: 0.06,
  morphStrength: 1.1
});

/* -----------------------------------------
   MINI BOXES (SCROLL)
----------------------------------------- */
document.querySelectorAll(".mini-box").forEach(box => {
  ScrollTrigger.create({
    trigger: box,
    start: "top 78%",
    once: true,
    onEnter: () => runMode(box, { morphStrength: 0.95 })
  });
});
</script>

<script>
(() => {
  const box = document.querySelector('.mode-squarepath');
  if (!box) return;

  const svg    = box.querySelector('.track-svg');
  const path   = box.querySelector('.track-path');
  const runner = box.querySelector('.runner');
  if (!svg || !path || !runner) return;

  const length = path.getTotalLength();
  const state  = { t: 0 };

  // ✅ solid line (NO dash animation)
  gsap.set(path, { strokeDasharray: "none", strokeDashoffset: 0 });

  // ✅ get runner size so we can center it on the path point
  const r = () => runner.getBoundingClientRect();
  const half = () => ({ hw: r().width / 2, hh: r().height / 2 });

  // helper: position runner on path at 0..1
  function placeRunner(t){
    const p = path.getPointAtLength(t * length);

    const svgRect = svg.getBoundingClientRect();
    const boxRect = box.getBoundingClientRect();
    const { hw, hh } = half();

    // viewBox is 0..100 x 0..150
    const x = (p.x / 100) * svgRect.width  + (svgRect.left - boxRect.left) - hw;
    const y = (p.y / 150) * svgRect.height + (svgRect.top  - boxRect.top) - hh;

    gsap.set(runner, { x, y });
  }

  // ✅ place at start immediately
  placeRunner(0);

  // ✅ continuous travel exactly on the path
  gsap.to(state, {
    t: 1,
    duration: 3.2,
    ease: "none",
    repeat: -1,
    onUpdate: () => placeRunner(state.t)
  });

  // optional: subtle pulse is fine (doesn't move off the line now)
  gsap.to(runner, {
    scale: 1.18,
    duration: 0.55,
    ease: "sine.inOut",
    yoyo: true,
    repeat: -1
  });

  // ✅ on resize, re-place runner (keeps it aligned)
  window.addEventListener("resize", () => placeRunner(state.t));
})();
</script>
<script>
/* ✅ DOT GRID: full-grid wave (TL -> BR), centerline dots largest, starts OFF-GRID then passes through */
(() => {
  const box  = document.querySelector("#designBox");
  const grid = box?.querySelector(".dot-grid");
  if (!box || !grid) return;

  // ---- TUNE ----
  const MIN_COLS = 25;
  const MIN_ROWS = 18;

  const GAP      = 18;
  const DOT_SIZE = 6;

  const BASE     = 0.55;
  const PEAK     = 3.05;      // max scale on the “spine”
  const DURATION = 5.0;       // seconds TL -> BR
  const RESET_GAP = 0.05;

  // ✅ start/end off-grid so it begins “farther back”
  const OVERSHOOT = 0.40;     // 0.25–0.60 (bigger = starts farther back)

  // wave shape controls
  const HEAD_RADIUS   = 0.34;  // overall wave radius (bigger = affects more grid)
  const SPINE_WIDTH   = 0.055; // thickness of the “biggest dot” band around diagonal
  const EDGE_FLOOR    = 0.18;  // how much the outer dots still react (0..1)
  const SOFTEN        = 0.85;  // makes the wave roll-in smoother

  // optional: make it feel a touch more organic (small per-dot variation)
  const JITTER_MIN = 0.92;
  const JITTER_MAX = 1.08;

  let dots = [];
  let cols = 0, rows = 0;
  let rafId = null;

  const gaussian = (d, s) => Math.exp(-(d * d) / (2 * s * s));
  const clamp01  = v => Math.max(0, Math.min(1, v));

  function build() {
    grid.innerHTML = "";
    dots = [];

    const r = grid.getBoundingClientRect();
    cols = Math.max(MIN_COLS, Math.floor(r.width  / GAP));
    rows = Math.max(MIN_ROWS, Math.floor(r.height / GAP));

    grid.style.gridTemplateColumns = `repeat(${cols}, ${GAP}px)`;
    grid.style.gridTemplateRows    = `repeat(${rows}, ${GAP}px)`;
    grid.style.setProperty("--dotSize", DOT_SIZE + "px");

    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        const el = document.createElement("div");
        el.className = "dot";
        grid.appendChild(el);

        const xn = x / Math.max(1, cols - 1);
        const yn = y / Math.max(1, rows - 1);

        dots.push({
          el,
          xn, yn,
          // perpendicular distance to the diagonal (0 on diagonal)
          perp: Math.abs(xn - yn) / Math.SQRT2,
          // tiny per-dot variety so it’s not perfectly uniform
          jitter: JITTER_MIN + Math.random() * (JITTER_MAX - JITTER_MIN)
        });
      }
    }
  }

  function animate(ms){
    const t = ms / 1000;

    // progress 0..1 with a small reset gap (clean restart)
    const raw  = (t % DURATION) / DURATION;
    const prog = clamp01((raw - RESET_GAP) / (1 - RESET_GAP));

    // ✅ start wave center off-grid → travel across → end off-grid
    const travel = 1 + OVERSHOOT * 2;
    const cx = -OVERSHOOT + prog * travel;
    const cy = -OVERSHOOT + prog * travel;

    for (const d of dots){
      // distance to moving center (affects whole grid)
      const dx = d.xn - cx;
      const dy = d.yn - cy;
      const dist = Math.hypot(dx, dy);

      // overall wave influence across the grid
      let wave = gaussian(dist, HEAD_RADIUS);

      // soften the leading edge so it starts smoother
      wave = Math.pow(wave, SOFTEN);

      // spine boost so diagonal band (the “currently going dots”) are largest
      const spine = gaussian(d.perp, SPINE_WIDTH);

      // combine:
      // - wave makes everything respond
      // - spine makes the center band respond MORE
      // - EDGE_FLOOR keeps outer dots from going dead
      const strength = wave * (EDGE_FLOOR + (1 - EDGE_FLOOR) * spine) * d.jitter;

      const s = BASE + (PEAK - BASE) * strength;
      const o = 0.20 + 0.80 * strength;

      d.el.style.setProperty("--s", s.toFixed(3));
      d.el.style.setProperty("--o", o.toFixed(3));
    }

    rafId = requestAnimationFrame(animate);
  }

  function start(){
    if (rafId) cancelAnimationFrame(rafId);
    build();
    rafId = requestAnimationFrame(animate);
  }

  start();

  // rebuild on resize (debounced)
  let rt;
  window.addEventListener("resize", () => {
    clearTimeout(rt);
    rt = setTimeout(start, 120);
  }, { passive:true });
})();
</script>
</body>
</html>